name: Release Shelly Drivers

on:
  workflow_dispatch:
    inputs:
      version_increment:
        description: "Version increment type"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
      release_notes:
        description: "Release notes for this version (summarize changes)"
        required: true
        type: string
      driver_category:
        description: "Driver category to release (or 'all')"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - WebhookWebsocket
          - Bluetooth
          - ComponentDrivers

jobs:
  release:
    name: Release Shelly Drivers
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Get current version and calculate new version
        id: version
        run: |
          # Extract current version from resources/version.json
          CURRENT_VERSION=$(jq -r '.versions.Driver."ShellyAsASwitch" // "3.0.10"' resources/version.json)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Parse version
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          # Increment based on input
          if [ "${{ github.event.inputs.version_increment }}" == "minor" ]; then
            minor=$((minor + 1))
            patch=0
          else
            patch=$((patch + 1))
          fi

          NEW_VERSION="${major}.${minor}.${patch}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Incrementing from $CURRENT_VERSION to $NEW_VERSION"

      - name: Update driver versions
        run: |
          OLD_VERSION="${{ steps.version.outputs.current_version }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          CATEGORY="${{ github.event.inputs.driver_category }}"

          echo "Updating version from $OLD_VERSION to $NEW_VERSION for category: $CATEGORY"

          # Function to update version in a driver file
          update_driver_version() {
            local file=$1
            if [ -f "$file" ]; then
              # Update version in metadata block
              sed -i "s/version: '$OLD_VERSION'/version: '$NEW_VERSION'/" "$file" || true
              sed -i "s/version: \"$OLD_VERSION\"/version: \"$NEW_VERSION\"/" "$file" || true
              echo "Updated $file"
            fi
          }

          # Update based on category (only non-legacy folders)
          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "WebhookWebsocket" ]; then
            for file in WebhookWebsocket/*.groovy; do
              update_driver_version "$file"
            done
          fi

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "Bluetooth" ]; then
            for file in Bluetooth/*.groovy; do
              update_driver_version "$file"
            done
          fi

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "ComponentDrivers" ]; then
            for file in ComponentDrivers/*.groovy; do
              update_driver_version "$file"
            done
          fi

          echo "Version update complete"

      - name: Update resources/version.json
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          RELEASE_NOTES="${{ github.event.inputs.release_notes }}"
          DATE=$(date +%m/%d/%Y)

          # Create Python script to update version.json
          cat > update_version.py << 'EOF'
          import json
          import sys

          version_path = 'resources/version.json'
          new_version = sys.argv[1]
          release_notes = sys.argv[2]
          date_updated = sys.argv[3]

          with open(version_path, 'r') as f:
              data = json.load(f)

          # Update Comment (date)
          data['Comment'] = f"Last updated: {date_updated}"

          # Update all driver versions to new version
          # This is a simplified approach - in practice you might want to track individual driver versions
          for driver_name in data['versions']['Driver'].keys():
              data['versions']['Driver'][driver_name] = new_version

          # Update UpdateInfo for drivers
          update_text = f"<br>- {release_notes}"
          for driver_name in data['versions']['Driver'].keys():
              if driver_name in data['UpdateInfo']['Driver']:
                  data['UpdateInfo']['Driver'][driver_name] = update_text
              else:
                  data['UpdateInfo']['Driver'][driver_name] = update_text

          with open(version_path, 'w') as f:
              json.dump(data, f, indent=2)

          print(f"Updated version.json to version {new_version}")
          EOF

          python3 update_version.py "$NEW_VERSION" "$RELEASE_NOTES" "$DATE"

      - name: Trigger library bundle workflow
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ShellyUSA_Driver_Library.yml',
                ref: 'master'
              });
              console.log('Triggered library bundle workflow');

              // Wait for it to complete
              let attempts = 0;
              const maxAttempts = 30;

              while (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 5000));

                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'ShellyUSA_Driver_Library.yml',
                  branch: 'master',
                  per_page: 5
                });

                const latestRun = runs.data.workflow_runs[0];

                if (latestRun && latestRun.status === 'completed') {
                  if (latestRun.conclusion === 'success') {
                    console.log('Library bundle workflow completed successfully');
                    break;
                  } else {
                    console.log(`Library bundle workflow failed: ${latestRun.conclusion}`);
                    break;
                  }
                }

                attempts++;
                console.log(`Waiting for library bundle... (${attempts}/${maxAttempts})`);
              }
            } catch (error) {
              console.log('Could not trigger library bundle workflow:', error.message);
            }

      - name: Generate changelog from git commits
        id: changelog
        run: |
          OLD_VERSION="${{ steps.version.outputs.current_version }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          CATEGORY="${{ github.event.inputs.driver_category }}"

          # Try to find the last version tag
          LAST_TAG=$(git tag -l "v${OLD_VERSION}" | head -n 1)

          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="--since='30 days ago'"
            echo "No previous tag found, using commits from last 30 days"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
            echo "Using commits since ${LAST_TAG}"
          fi

          # Generate changelog based on category (only non-legacy folders)
          if [ "$CATEGORY" == "all" ]; then
            CHANGELOG=$(git log $COMMIT_RANGE --pretty=format:"- %s" --no-merges -- \
              WebhookWebsocket/ \
              Bluetooth/ \
              ComponentDrivers/ \
              ShellyDriverLibrary/ \
              PackageManifests/ \
              resources/version.json || echo "- Release ${NEW_VERSION}")
          else
            CHANGELOG=$(git log $COMMIT_RANGE --pretty=format:"- %s" --no-merges -- \
              "${CATEGORY}/" \
              "ShellyDriverLibrary/" \
              "resources/version.json" || echo "- Release ${NEW_VERSION}")
          fi

          # Save changelog to file
          cat > changelog.md << EOF
          ## Shelly Drivers ${NEW_VERSION}

          ### Release Notes
          ${{ github.event.inputs.release_notes }}

          ### Category
          ${CATEGORY}

          ### Changes in this release
          ${CHANGELOG}

          ### Installation
          - Download the driver files from the release assets
          - Install via Hubitat Package Manager (HPM) - recommended
          - Or manually copy the code to Hubitat Drivers Code section

          ### Documentation
          See the [README](https://github.com/${{ github.repository }}) for detailed installation and usage instructions.
          EOF

          echo "Changelog generated"

      - name: Commit version updates
        uses: EndBug/add-and-commit@v9
        with:
          add: |
            WebhookWebsocket/*.groovy
            Bluetooth/*.groovy
            ComponentDrivers/*.groovy
            ShellyDriverLibrary/
            resources/version.json
          message: "Release Shelly Drivers ${{ steps.version.outputs.new_version }}"
          tag: "v${{ steps.version.outputs.new_version }}"
          push: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.new_version }}
          name: Shelly Drivers ${{ steps.version.outputs.new_version }}
          body_path: changelog.md
          draft: false
          prerelease: false
          files: |
            WebhookWebsocket/*.groovy
            Bluetooth/*.groovy
            ComponentDrivers/*.groovy
            ShellyDriverLibrary/*.groovy
            ShellyUSA_Driver_Library.zip
            resources/version.json
            PackageManifests/**/packageManifest.json
            README.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Discussion Announcement
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            const changelog = fs.readFileSync('changelog.md', 'utf8');

            try {
              const categories = await github.graphql(`
                query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    discussionCategories(first: 10) {
                      nodes {
                        id
                        name
                      }
                    }
                  }
                }
              `, {
                owner: context.repo.owner,
                repo: context.repo.repo
              });

              const announcementCategory = categories.repository.discussionCategories.nodes.find(
                cat => cat.name === 'Announcements'
              );

              if (!announcementCategory) {
                console.log('Announcements category not found, skipping discussion creation');
                return;
              }

              await github.graphql(`
                mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
                  createDiscussion(input: {
                    repositoryId: $repositoryId,
                    categoryId: $categoryId,
                    title: $title,
                    body: $body
                  }) {
                    discussion {
                      url
                    }
                  }
                }
              `, {
                repositoryId: context.payload.repository.node_id,
                categoryId: announcementCategory.id,
                title: `Shelly Drivers ${{ steps.version.outputs.new_version }} Released`,
                body: changelog
              });

              console.log('Discussion announcement created successfully');
            } catch (error) {
              console.log('Could not create discussion:', error.message);
            }

      - name: Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Release Complete! ðŸŽ‰

          ## Version
          - **From:** ${{ steps.version.outputs.current_version }}
          - **To:** ${{ steps.version.outputs.new_version }}

          ## Category
          **${{ github.event.inputs.driver_category }}**

          ## What was done
          1. âœ… Updated version numbers in driver files
          2. âœ… Updated resources/version.json
          3. âœ… Triggered library bundle workflow
          4. âœ… Created git tag: v${{ steps.version.outputs.new_version }}
          5. âœ… Created GitHub Release with driver files
          6. âœ… Attempted to create discussion announcement

          ## Next Steps
          - Verify the release at: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.new_version }}
          - Test the updated drivers on your Hubitat hub
          - Update Hubitat Package Manager manifests if applicable
          - Announce the release to the Hubitat community

          ## Files Released
          - All driver files from selected category
          - Shelly Driver Library
          - Updated version.json
          - README.md
          EOF
