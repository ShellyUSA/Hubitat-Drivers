name: Release Shelly Drivers

on:
  workflow_dispatch:
    inputs:
      version_increment:
        description: "Version increment type"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
      release_notes:
        description: "Release notes for this version (summarize changes)"
        required: true
        type: string
      driver_category:
        description: "Driver category to release (or 'all')"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - WebhookWebsocket
          - Bluetooth
          - ComponentDrivers

jobs:
  release:
    name: Release Shelly Drivers
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Get current version and calculate new version
        id: version
        run: |
          CURRENT_VERSION=$(grep -m 1 "Version:" WebhookWebsocket/*.groovy | head -1 | sed -n 's/.*Version: \([0-9.]*\).*/\1/p' || echo "2.0.0")
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          if [ "${{ github.event.inputs.version_increment }}" == "minor" ]; then
            minor=$((minor + 1))
            patch=0
          else
            patch=$((patch + 1))
          fi

          NEW_VERSION="${major}.${minor}.${patch}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Incrementing from $CURRENT_VERSION to $NEW_VERSION"

      - name: Update driver versions
        run: |
          OLD_VERSION="${{ steps.version.outputs.current_version }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          CATEGORY="${{ github.event.inputs.driver_category }}"

          echo "Updating version from $OLD_VERSION to $NEW_VERSION for category: $CATEGORY"

          update_driver_version() {
            local file=$1
            if [ -f "$file" ]; then
              sed -i "s/Version: $OLD_VERSION/Version: $NEW_VERSION/" "$file"
              echo "Updated $file"
            fi
          }

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "WebhookWebsocket" ]; then
            for file in WebhookWebsocket/*.groovy; do
              update_driver_version "$file"
            done
          fi

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "Bluetooth" ]; then
            for file in Bluetooth/*.groovy; do
              update_driver_version "$file"
            done
          fi

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "ComponentDrivers" ]; then
            for file in ComponentDrivers/*.groovy; do
              update_driver_version "$file"
            done
          fi

          sed -i "s/Version: $OLD_VERSION/Version: $NEW_VERSION/" ShellyDriverLibrary/*.groovy

          echo "Version update complete"

      - name: Remove old library bundle zip files
        run: |
          echo "Removing old library bundle zip files from repo..."
          git rm -f ShellyUSA_Driver_Library*.zip 2>/dev/null || true
          rm -f ShellyUSA_Driver_Library*.zip 2>/dev/null || true
          echo "Old zip files removed"

      - name: Create library bundle with updated version
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          echo "Creating Shelly Driver Library bundle v$NEW_VERSION..."

          cd ShellyDriverLibrary
          zip -r "../ShellyUSA_Driver_Library-v${NEW_VERSION}.zip" *.groovy *.txt
          cd ..

          if [ -f "ShellyUSA_Driver_Library-v${NEW_VERSION}.zip" ]; then
            echo "Bundle created: ShellyUSA_Driver_Library-v${NEW_VERSION}.zip"
            ls -lh "ShellyUSA_Driver_Library-v${NEW_VERSION}.zip"
            unzip -l "ShellyUSA_Driver_Library-v${NEW_VERSION}.zip"
          else
            echo "ERROR: Failed to create versioned bundle!"
            exit 1
          fi

      - name: Generate changelog
        run: |
          OLD_VERSION="${{ steps.version.outputs.current_version }}"
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          CATEGORY="${{ github.event.inputs.driver_category }}"
          RELEASE_NOTES="${{ github.event.inputs.release_notes }}"

          LAST_TAG=$(git tag -l "v${OLD_VERSION}" | head -n 1)

          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="--since='30 days ago'"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi

          if [ "$CATEGORY" == "all" ]; then
            CHANGELOG=$(git log $COMMIT_RANGE --pretty=format:"- %s" --no-merges -- \
              WebhookWebsocket/ Bluetooth/ ComponentDrivers/ \
              ShellyDriverLibrary/ PackageManifests/ || echo "- Release ${NEW_VERSION}")
          else
            CHANGELOG=$(git log $COMMIT_RANGE --pretty=format:"- %s" --no-merges -- \
              "${CATEGORY}/" "ShellyDriverLibrary/" || echo "- Release ${NEW_VERSION}")
          fi

          {
            echo "## Shelly Drivers ${NEW_VERSION}"
            echo ""
            echo "### Release Notes"
            echo "${RELEASE_NOTES}"
            echo ""
            echo "### Category"
            echo "${CATEGORY}"
            echo ""
            echo "### Changes in this release"
            echo "${CHANGELOG}"
            echo ""
            echo "### Installation"
            echo "- Install via Hubitat Package Manager (HPM) - recommended"
            echo "- Or manually copy the code to Hubitat Drivers Code section"
          } > changelog.md

          echo "Changelog generated"

      - name: Create versioned copies of driver files
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          CATEGORY="${{ github.event.inputs.driver_category }}"

          mkdir -p release-files

          version_file() {
            local file=$1
            local basename_val=$(basename "$file")
            local filename_noext="${basename_val%.groovy}"
            local versioned_name="${filename_noext}-v${NEW_VERSION}.groovy"
            cp "$file" "release-files/$versioned_name"
            echo "Created versioned file: $versioned_name"

            # If filename contains &, also create a URL-encoded copy (%26)
            if [[ "$versioned_name" == *'&'* ]]; then
              local encoded_name="${versioned_name//&/%26}"
              cp "$file" "release-files/$encoded_name"
              echo "Created URL-encoded copy: $encoded_name"
            fi
          }

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "WebhookWebsocket" ]; then
            for file in WebhookWebsocket/*.groovy; do
              [ -f "$file" ] && version_file "$file"
            done
          fi

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "Bluetooth" ]; then
            for file in Bluetooth/*.groovy; do
              [ -f "$file" ] && version_file "$file"
            done
          fi

          if [ "$CATEGORY" == "all" ] || [ "$CATEGORY" == "ComponentDrivers" ]; then
            for file in ComponentDrivers/*.groovy; do
              [ -f "$file" ] && version_file "$file"
            done
          fi

          echo "All driver files versioned and ready for release"

      - name: Update package manifests with release URLs
        run: |
          python3 .github/scripts/update_manifests.py "${{ steps.version.outputs.new_version }}"

      - name: Verify release files match manifest
        run: |
          python3 .github/scripts/verify_release_files.py

      - name: Pull latest changes before committing
        run: |
          git config pull.rebase true
          git pull origin master || echo "No changes to pull"

      - name: Commit version updates
        uses: EndBug/add-and-commit@v9
        with:
          add: |
            WebhookWebsocket/*.groovy
            Bluetooth/*.groovy
            ComponentDrivers/*.groovy
            ShellyDriverLibrary/*.groovy
            ShellyUSA_Driver_Library-v${{ steps.version.outputs.new_version }}.zip
            PackageManifests/**/packageManifest.json
          message: "Release Shelly Drivers ${{ steps.version.outputs.new_version }}"
          tag: "v${{ steps.version.outputs.new_version }}"
          pull: "--rebase --autostash"
          push: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.new_version }}
          name: Shelly Drivers ${{ steps.version.outputs.new_version }}
          body_path: changelog.md
          draft: false
          prerelease: false
          files: |
            release-files/*
            ShellyUSA_Driver_Library-v${{ steps.version.outputs.new_version }}.zip
            PackageManifests/**/packageManifest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Discussion Announcement
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            const changelog = fs.readFileSync('changelog.md', 'utf8');

            try {
              const categories = await github.graphql(`
                query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    discussionCategories(first: 10) {
                      nodes {
                        id
                        name
                      }
                    }
                  }
                }
              `, {
                owner: context.repo.owner,
                repo: context.repo.repo
              });

              const announcementCategory = categories.repository.discussionCategories.nodes.find(
                cat => cat.name === 'Announcements'
              );

              if (!announcementCategory) {
                console.log('Announcements category not found, skipping discussion creation');
                return;
              }

              await github.graphql(`
                mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
                  createDiscussion(input: {
                    repositoryId: $repositoryId,
                    categoryId: $categoryId,
                    title: $title,
                    body: $body
                  }) {
                    discussion {
                      url
                    }
                  }
                }
              `, {
                repositoryId: context.payload.repository.node_id,
                categoryId: announcementCategory.id,
                title: `Shelly Drivers ${{ steps.version.outputs.new_version }} Released`,
                body: changelog
              });

              console.log('Discussion announcement created successfully');
            } catch (error) {
              console.log('Could not create discussion:', error.message);
            }

      - name: Summary
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          {
            echo "# Release Complete!"
            echo ""
            echo "**Version:** ${{ steps.version.outputs.current_version }} -> ${NEW_VERSION}"
            echo "**Category:** ${{ github.event.inputs.driver_category }}"
            echo ""
            echo "## What was done"
            echo "1. Updated version comments in all driver files"
            echo "2. Removed old library bundle zips"
            echo "3. Created library bundle zip v${NEW_VERSION}"
            echo "4. Updated package manifests with release URLs"
            echo "5. Verified all release files match manifest"
            echo "6. Created git tag: v${NEW_VERSION}"
            echo "7. Created GitHub Release (only manifest-referenced files)"
            echo ""
            echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v${NEW_VERSION})"
          } >> "$GITHUB_STEP_SUMMARY"
